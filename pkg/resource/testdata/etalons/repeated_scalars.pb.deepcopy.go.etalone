// Code generated by protoc-gen-resource. DO NOT EDIT.

package protos

import (
	"fmt"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// to resolve imports
var _ fmt.Formatter

func (*ABitOfRepeatedScalars) GetResourceGroup() string {
	return "test.api.nrm.netcracker.com"
}

// API Version, equals to "hub"
func (*ABitOfRepeatedScalars) GetResourceVersion() string {
	return "hub"
}

// Resource Kind, equals to "ABitOfRepeatedScalars"
func (*ABitOfRepeatedScalars) GetResourceKind() string {
	return "ABitOfRepeatedScalars"
}

// GetObjectKind to satisfy runtime.Object interface
func (x *ABitOfRepeatedScalars) GetObjectKind() schema.ObjectKind {
	typeMeta := meta.TypeMeta{}
	typeMeta.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "test.api.nrm.netcracker.com",
		Version: "hub",
		Kind:    "ABitOfRepeatedScalars",
	})
	return &typeMeta
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ABitOfRepeatedScalars) DeepCopyInto(out *ABitOfRepeatedScalars) {

	if in.DoubleType != nil {
		in, out := &in.DoubleType, &out.DoubleType
		*out = make([]float64, len(*in))
		copy(*out, *in)
	}

	if in.FloatType != nil {
		in, out := &in.FloatType, &out.FloatType
		*out = make([]float32, len(*in))
		copy(*out, *in)
	}

	if in.Int32Type != nil {
		in, out := &in.Int32Type, &out.Int32Type
		*out = make([]int32, len(*in))
		copy(*out, *in)
	}

	if in.Int64Type != nil {
		in, out := &in.Int64Type, &out.Int64Type
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}

	if in.Uint32Type != nil {
		in, out := &in.Uint32Type, &out.Uint32Type
		*out = make([]uint32, len(*in))
		copy(*out, *in)
	}

	if in.Uint64Type != nil {
		in, out := &in.Uint64Type, &out.Uint64Type
		*out = make([]uint64, len(*in))
		copy(*out, *in)
	}

	if in.Sint32Type != nil {
		in, out := &in.Sint32Type, &out.Sint32Type
		*out = make([]int32, len(*in))
		copy(*out, *in)
	}

	if in.Sint64Type != nil {
		in, out := &in.Sint64Type, &out.Sint64Type
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}

	if in.Fixed32Type != nil {
		in, out := &in.Fixed32Type, &out.Fixed32Type
		*out = make([]uint32, len(*in))
		copy(*out, *in)
	}

	if in.Fixed64Type != nil {
		in, out := &in.Fixed64Type, &out.Fixed64Type
		*out = make([]uint64, len(*in))
		copy(*out, *in)
	}

	if in.Sfixed32Type != nil {
		in, out := &in.Sfixed32Type, &out.Sfixed32Type
		*out = make([]int32, len(*in))
		copy(*out, *in)
	}

	if in.Sfixed64Type != nil {
		in, out := &in.Sfixed64Type, &out.Sfixed64Type
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}

	if in.BoolType != nil {
		in, out := &in.BoolType, &out.BoolType
		*out = make([]bool, len(*in))
		copy(*out, *in)
	}

	if in.StringType != nil {
		in, out := &in.StringType, &out.StringType
		*out = make([]string, len(*in))
		copy(*out, *in)
	}

	if in.BytesType != nil {
		in, out := &in.BytesType, &out.BytesType
		*out = make([][]byte, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Condition.
func (in *ABitOfRepeatedScalars) DeepCopy() *ABitOfRepeatedScalars {
	if in == nil {
		return nil
	}
	out := new(ABitOfRepeatedScalars)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, returning deepcopy as runtime.Object interface.
func (in *ABitOfRepeatedScalars) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}
